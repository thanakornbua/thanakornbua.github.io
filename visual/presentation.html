<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Presentation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="app.css" />
    <script>
      (() => {
        const key = 'theme';
        let stored = null;
        try {
          stored = localStorage.getItem(key);
        } catch (err) {
          stored = null;
        }
        const preferDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const theme = stored || (preferDark ? 'dark' : 'light');
        document.documentElement.dataset.theme = theme;
      })();
    </script>
    <style>
      #viewerShell:fullscreen {
        width: 100vw;
        height: 100vh;
        max-width: none;
        max-height: none;
        border-radius: 0;
        border: none;
        background: #000;
      }
      #viewerShell:fullscreen .viewerTopbar {
        border-radius: 0;
      }
      #viewerShell:fullscreen .viewerBody {
        height: 100%;
        min-height: 0;
      }
      #viewerShell:fullscreen #stage {
        height: 100%;
      }
    </style>
  </head>
  <body class="page">
    <div class="backdrop" aria-hidden="true">
      <div class="orb one"></div>
      <div class="orb two"></div>
      <div class="orb three"></div>
      <div class="gridOverlay"></div>
    </div>

    <div class="container content">
      <header class="header">
        <div class="brand">
          <h1>Presentation</h1>
          <p>Pick a date, choose a PDF, then present</p>
        </div>
        <div class="nav">
          <a href="index.html" class="btn">Home</a>
          <a href="rerieve.html" class="btn">Retrieve</a>
          <button id="themeToggle" type="button" class="btn" aria-label="Toggle theme">
            <svg id="iconSun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-4 w-4" width="16" height="16">
              <path d="M12 18a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" />
              <path fill-rule="evenodd" d="M12 1.25a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0V2a.75.75 0 0 1 .75-.75ZM3.49 3.49a.75.75 0 0 1 1.06 0l1.06 1.06a.75.75 0 1 1-1.06 1.06L3.49 4.55a.75.75 0 0 1 0-1.06ZM21.25 12a.75.75 0 0 1-.75.75H19a.75.75 0 0 1 0-1.5h1.5a.75.75 0 0 1 .75.75ZM5 12a.75.75 0 0 1-.75.75H2.75a.75.75 0 0 1 0-1.5h1.5A.75.75 0 0 1 5 12Zm14.45-8.51a.75.75 0 0 1 1.06 1.06l-1.06 1.06a.75.75 0 0 1-1.06-1.06l1.06-1.06ZM12 19.25a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-1.5 0V20a.75.75 0 0 1 .75-.75ZM4.55 18.39a.75.75 0 0 1 1.06 0l1.06 1.06a.75.75 0 1 1-1.06 1.06l-1.06-1.06a.75.75 0 0 1 0-1.06Zm13.78 0a.75.75 0 0 1 1.06 1.06l-1.06 1.06a.75.75 0 0 1-1.06-1.06l1.06-1.06Z" clip-rule="evenodd" />
            </svg>
            <svg id="iconMoon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="h-4 w-4" width="16" height="16">
              <path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6.75a9 9 0 0 0 9 9 8.97 8.97 0 0 0 4.213-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-3.97 2.196-7.428 5.528-9.282Z" clip-rule="evenodd" />
            </svg>
            <span id="themeLabel">Theme</span>
          </button>
        </div>
      </header>

      <main class="layout">
        <aside class="panel layoutSidebar">
          <div class="panelHeader">
            <div>
              <h2>Library</h2>
              <p class="small">Pick a date and select a PDF.</p>
            </div>
            <button id="reload" type="button" class="btn ghost">Reload</button>
          </div>

          <div class="panelBody">
            <div class="formRow">
              <div class="field">
                <label for="date">Presentation date</label>
                <input id="date" type="date" />
              </div>
              <div class="field fieldAction">
                <button id="load" type="button" class="btn primary">Load PDFs</button>
              </div>
            </div>

            <div id="status" class="notice hidden"></div>

            <div class="section">
              <div class="sectionTitle">Available dates</div>
              <div id="dates" class="list compact"></div>
            </div>

            <div class="section">
              <div class="sectionTitle">Files on selected date</div>
              <div id="files" class="list"></div>
            </div>
          </div>
        </aside>

        <section id="viewerShell" class="viewerShell layoutViewer">
          <div class="viewerTopbar">
            <div class="left">
              <button id="prev" class="btn" type="button">Prev</button>
              <button id="next" class="btn" type="button">Next</button>
              <div id="pageInfo" class="small">No file loaded</div>
            </div>
            <div class="right">
              <button id="fit" class="btn" type="button">Fit</button>
              <button id="zoomOut" class="btn" type="button">-</button>
              <div id="zoomLabel" class="small" style="min-width:48px;text-align:center;">100%</div>
              <button id="zoomIn" class="btn" type="button">+</button>
              <button id="presenter" class="btn accent" type="button">Presenter view</button>
              <button id="fullscreen" class="btn" type="button">Fullscreen</button>
              <button id="close" class="btn" type="button">Close</button>
            </div>
          </div>

          <div class="viewerBody">
            <div class="thumbs" id="thumbs"></div>
            <div class="stage" id="stage">
              <div class="stageInner">
                <canvas id="pdfCanvas"></canvas>
              </div>
              <div class="hint">Click: Next (Shift+Click: Prev) • Keys: ←/→, PgUp/PgDn, Space, F</div>
              <div id="metaOverlay" class="metaOverlay hidden"></div>
              <div id="loading" class="loadingOverlay">
                <div class="loadingCard">Loading…</div>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>

    <script src="shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
      (() => {
        const btn = document.getElementById('themeToggle');
        if (!btn) return;
        const iconSun = document.getElementById('iconSun');
        const iconMoon = document.getElementById('iconMoon');
        const label = document.getElementById('themeLabel');
        const storageKey = 'theme';
        const prefersDarkMedia = window.matchMedia ? window.matchMedia('(prefers-color-scheme: dark)') : null;

        const readStored = () => {
          try {
            return localStorage.getItem(storageKey);
          } catch (err) {
            return null;
          }
        };
        const writeStored = (value) => {
          try {
            localStorage.setItem(storageKey, value);
          } catch (err) {
            // ignore write errors
          }
        };

        const apply = (theme, options = {}) => {
          const next = theme === 'dark' ? 'dark' : 'light';
          document.documentElement.dataset.theme = next;
          if (options.persist !== false) {
            writeStored(next);
          }
          const isDark = next === 'dark';
          if (iconSun) iconSun.style.display = isDark ? 'inline-block' : 'none';
          if (iconMoon) iconMoon.style.display = isDark ? 'none' : 'inline-block';
          if (label) label.textContent = isDark ? 'Dark' : 'Light';
          btn.setAttribute('aria-pressed', String(isDark));
        };

        const initial = readStored() || (prefersDarkMedia && prefersDarkMedia.matches ? 'dark' : 'light');
        apply(initial, { persist: false });

        btn.addEventListener('click', () => {
          const isDark = document.documentElement.dataset.theme === 'dark';
          apply(isDark ? 'light' : 'dark');
        });

        if (prefersDarkMedia) {
          prefersDarkMedia.addEventListener('change', (event) => {
            if (readStored()) return;
            apply(event.matches ? 'dark' : 'light', { persist: false });
          });
        }
      })();

      const params = new URLSearchParams(location.search);
      const deepDate = params.get('date') || '';
      const deepOpenId = params.get('open') || '';

      const dateEl = document.getElementById('date');
      const loadEl = document.getElementById('load');
      const reloadEl = document.getElementById('reload');
      const statusEl = document.getElementById('status');
      const datesEl = document.getElementById('dates');
      const filesEl = document.getElementById('files');

      const thumbsEl = document.getElementById('thumbs');
      const stageEl = document.getElementById('stage');
      const loadingEl = document.getElementById('loading');
      const canvas = document.getElementById('pdfCanvas');
      const ctx = canvas.getContext('2d', { alpha: false });

      const pageInfoEl = document.getElementById('pageInfo');
      const zoomLabelEl = document.getElementById('zoomLabel');
      const prevEl = document.getElementById('prev');
      const nextEl = document.getElementById('next');
      const fitEl = document.getElementById('fit');
      const zoomInEl = document.getElementById('zoomIn');
      const zoomOutEl = document.getElementById('zoomOut');
      const fullscreenEl = document.getElementById('fullscreen');
      const closeEl = document.getElementById('close');
      const presenterEl = document.getElementById('presenter');
      const metaOverlayEl = document.getElementById('metaOverlay');

      const bc = ('BroadcastChannel' in window) ? new BroadcastChannel('pdf-presenter') : null;

      let indexData = null;
      let currentDateKey = '';
      let currentEntries = [];
      let currentPdf = null;
      let currentSrc = '';
      let currentMetaDate = '';
      let currentMetaCode = '';
      let currentPage = 1;
      let pageCount = 0;
      let zoom = 1;
      let fitMode = true;
      let renderToken = 0;
      let thumbsBuilt = false;

      function updateMetaOverlay() {
        const parts = [];
        if (currentMetaDate) parts.push(`Date: ${currentMetaDate}`);
        if (currentMetaCode) parts.push(`Code: ${currentMetaCode}`);
        metaOverlayEl.textContent = parts.join('  •  ');
        metaOverlayEl.classList.toggle('hidden', parts.length === 0);
      }

      function setStatus(message, kind = 'info') {
        statusEl.classList.toggle('hidden', !message);
        statusEl.textContent = message || '';
        statusEl.classList.toggle('warn', kind === 'warn');
      }

      function setLoading(isLoading) {
        loadingEl.classList.toggle('active', isLoading);
      }

      function clear(elm) {
        elm.innerHTML = '';
      }

      function renderDatesList() {
        clear(datesEl);
        const keys = Object.keys(indexData?.dates || {}).sort().reverse();
        if (!keys.length) {
          datesEl.appendChild(el('div', { class: 'listEmpty' }, 'No dates in presentations.json'));
          return;
        }
        for (const key of keys) {
          const count = (indexData.dates[key] || []).length;
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn listButton';
          btn.innerHTML = `<span>${key}</span><span class="small">${count}</span>`;
          btn.addEventListener('click', async () => {
            dateEl.value = key;
            await loadForDate(key);
          });
          datesEl.appendChild(btn);
        }
      }

      function renderFilesList() {
        clear(filesEl);
        if (!currentEntries.length) {
          filesEl.appendChild(el('div', { class: 'listEmpty' }, 'No files for selected date.'));
          return;
        }
        for (const entry of currentEntries) {
          const name = entry.title || entry.id || entry.file;
          const row = document.createElement('div');
          row.className = 'item';
          row.appendChild(el('h3', {}, name));
          row.appendChild(el('div', { class: 'meta' }, entry.code ? `Code: ${entry.code}` : ''));
          const actions = document.createElement('div');
          actions.className = 'actions';
          const presentBtn = document.createElement('button');
          presentBtn.type = 'button';
          presentBtn.className = 'btn primary';
          presentBtn.textContent = 'Present';
          presentBtn.addEventListener('click', () => openViewer(entry));
          actions.appendChild(presentBtn);
          actions.appendChild(el('a', { class: 'btn', href: resolveFileUrl(entry.file), download: '' }, 'Download'));
          row.appendChild(actions);
          filesEl.appendChild(row);
        }
      }

      async function loadIndex(force = false) {
        try {
          if (force) indexData = null;
          if (!indexData) indexData = await loadPresentationsIndex();
          renderDatesList();
          return true;
        } catch (err) {
          setStatus(err.message || String(err), 'warn');
          return false;
        }
      }

      async function loadForDate(dateKey) {
        setStatus('');
        const ok = await loadIndex(false);
        if (!ok) return;

        currentDateKey = dateKey;
        currentEntries = indexData.dates[dateKey] || [];
        if (!currentEntries.length) {
          setStatus('No files found for that date.', 'warn');
        } else {
          setStatus(`Found ${currentEntries.length} file(s) for ${dateKey}.`);
        }
        renderFilesList();

        if (deepOpenId) {
          const match = currentEntries.find(e => String(e.id) === String(deepOpenId));
          if (match) openViewer(match);
        }
      }

      function updateZoomLabel() {
        zoomLabelEl.textContent = `${Math.round(zoom * 100)}%`;
      }

      function getFitScale(page) {
        const viewport = page.getViewport({ scale: 1 });
        const box = stageEl.getBoundingClientRect();
        const pad = 32;
        const scaleX = (box.width - pad) / viewport.width;
        const scaleY = (box.height - pad) / viewport.height;
        return Math.max(0.1, Math.min(scaleX, scaleY));
      }

      async function renderPage(pageNumber, reason = 'nav') {
        if (!currentPdf) return;
        const myToken = ++renderToken;

        currentPage = Math.max(1, Math.min(pageCount, pageNumber));
        setLoading(true);
        try {
          const page = await currentPdf.getPage(currentPage);
          if (myToken !== renderToken) return;

          const scale = fitMode ? getFitScale(page) : zoom;
          const viewport = page.getViewport({ scale });
          canvas.width = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);
          await page.render({ canvasContext: ctx, viewport }).promise;
          if (myToken !== renderToken) return;

          pageInfoEl.textContent = `${currentDateKey ? currentDateKey + '  •  ' : ''}Page ${currentPage} / ${pageCount}`;
          highlightThumb(currentPage);
          if (bc) bc.postMessage({ type: 'page', page: currentPage, total: pageCount, src: currentSrc });
          if (reason === 'open') stageEl.scrollTo({ top: 0, left: 0 });
        } finally {
          setLoading(false);
        }
      }

      function highlightThumb(pageNumber) {
        const buttons = thumbsEl.querySelectorAll('[data-page]');
        for (const btn of buttons) {
          const active = Number(btn.dataset.page) === pageNumber;
          btn.setAttribute('aria-current', active ? 'true' : 'false');
        }
      }

      function buildThumbs() {
        if (!currentPdf || thumbsBuilt) return;
        thumbsBuilt = true;
        clear(thumbsEl);

        const maxThumbs = Math.min(pageCount, 120);
        for (let p = 1; p <= maxThumbs; p++) {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.dataset.page = String(p);
          btn.className = 'thumbBtn';
          btn.addEventListener('click', () => renderPage(p));

          const thumbCanvas = document.createElement('canvas');
          thumbCanvas.className = 'thumbCanvas';
          const label = document.createElement('div');
          label.className = 'thumbLabel';
          label.innerHTML = `<div class="t">Slide</div><div class="p">#${p}</div>`;
          const outer = document.createElement('div');
          outer.style.display = 'flex';
          outer.style.alignItems = 'center';
          outer.style.gap = '10px';
          outer.appendChild(thumbCanvas);
          outer.appendChild(label);
          btn.appendChild(outer);
          thumbsEl.appendChild(btn);

          const io = new IntersectionObserver(async (entries, obs) => {
            for (const e of entries) {
              if (!e.isIntersecting) continue;
              obs.unobserve(e.target);
              try {
                const page = await currentPdf.getPage(p);
                const viewport = page.getViewport({ scale: 0.18 });
                thumbCanvas.width = Math.floor(viewport.width);
                thumbCanvas.height = Math.floor(viewport.height);
                const tctx = thumbCanvas.getContext('2d', { alpha: false });
                await page.render({ canvasContext: tctx, viewport }).promise;
              } catch {
                // ignore thumb errors
              }
            }
          }, { root: thumbsEl, rootMargin: '900px' });

          io.observe(btn);
        }
        highlightThumb(currentPage);
      }

      async function openViewer(entry) {
        setStatus('');
        if (!window.pdfjsLib) {
          setStatus('PDF viewer failed to initialize (pdfjsLib not found). Check network access to cdnjs.', 'warn');
          return;
        }

        setLoading(true);
        currentSrc = resolveFileUrl(entry.file);
        currentMetaDate = currentDateKey || '';
        currentMetaCode = (entry && entry.code) ? String(entry.code) : '';
        updateMetaOverlay();
        currentPdf = null;
        currentPage = 1;
        pageCount = 0;
        fitMode = true;
        zoom = 1;
        updateZoomLabel();
        thumbsBuilt = false;
        clear(thumbsEl);
        pageInfoEl.textContent = 'Loading…';

        const workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;

        try {
          currentPdf = await window.pdfjsLib.getDocument({ url: currentSrc }).promise;
          pageCount = currentPdf.numPages;
          await renderPage(1, 'open');
          buildThumbs();
        } catch (err) {
          setStatus(`Failed to load PDF: ${err.message || err}`, 'warn');
          pageInfoEl.textContent = 'No file loaded';
        } finally {
          setLoading(false);
        }
      }

      function closeViewer() {
        currentPdf = null;
        currentSrc = '';
        currentMetaDate = '';
        currentMetaCode = '';
        updateMetaOverlay();
        pageCount = 0;
        currentPage = 1;
        thumbsBuilt = false;
        clear(thumbsEl);
        pageInfoEl.textContent = 'No file loaded';
        canvas.width = 1;
        canvas.height = 1;
      }

      async function nextPage() {
        if (!currentPdf) return;
        await renderPage(currentPage + 1);
      }

      async function prevPage() {
        if (!currentPdf) return;
        await renderPage(currentPage - 1);
      }

      async function toggleFullscreen() {
        const target = document.getElementById('viewerShell');
        if (!target) return;
        if (!document.fullscreenElement) await target.requestFullscreen?.();
        else await document.exitFullscreen?.();
      }

      function openPresenterView() {
        if (!currentSrc || !currentPdf) return;
        const url = new URL('presenter.html', location.href);
        url.searchParams.set('src', currentSrc);
        url.searchParams.set('page', String(currentPage));
        if (currentMetaDate) url.searchParams.set('date', currentMetaDate);
        if (currentMetaCode) url.searchParams.set('code', currentMetaCode);
        window.open(url.toString(), 'PresenterView', 'popup,width=1200,height=780');
      }

      if (bc) {
        bc.onmessage = (evt) => {
          const msg = evt.data;
          if (!msg || msg.type !== 'goto') return;
          if (!currentPdf) return;
          if (msg.src !== currentSrc) return;
          const next = Number(msg.page);
          if (!Number.isFinite(next)) return;
          renderPage(next, 'nav');
        };
      }

      const ro = new ResizeObserver(() => {
        if (!currentPdf) return;
        if (!fitMode) return;
        renderPage(currentPage, 'resize');
      });
      ro.observe(stageEl);

      prevEl.addEventListener('click', prevPage);
      nextEl.addEventListener('click', nextPage);
      fullscreenEl.addEventListener('click', toggleFullscreen);
      closeEl.addEventListener('click', closeViewer);
      presenterEl.addEventListener('click', openPresenterView);
      canvas.addEventListener('click', (e) => {
        if (!currentPdf) return;
        if (e.shiftKey) prevPage();
        else nextPage();
      });

      fitEl.addEventListener('click', async () => {
        if (!currentPdf) return;
        fitMode = true;
        zoom = 1;
        updateZoomLabel();
        await renderPage(currentPage, 'fit');
      });

      zoomInEl.addEventListener('click', async () => {
        if (!currentPdf) return;
        fitMode = false;
        zoom = Math.min(3, Math.round((zoom + 0.1) * 10) / 10);
        updateZoomLabel();
        await renderPage(currentPage, 'zoom');
      });

      zoomOutEl.addEventListener('click', async () => {
        if (!currentPdf) return;
        fitMode = false;
        zoom = Math.max(0.3, Math.round((zoom - 0.1) * 10) / 10);
        updateZoomLabel();
        await renderPage(currentPage, 'zoom');
      });

      loadEl.addEventListener('click', async () => {
        const dateKey = normalizeDateKey(dateEl.value);
        if (!dateKey) {
          setStatus('Please select a date.', 'warn');
          return;
        }
        await loadForDate(dateKey);
      });

      reloadEl.addEventListener('click', async () => {
        setStatus('Reloading index…');
        await loadIndex(true);
        setStatus('');
      });

      window.addEventListener('keydown', (e) => {
        if (e.target && ['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return;
        if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') {
          e.preventDefault();
          if (e.shiftKey && e.key === ' ') prevPage();
          else nextPage();
        } else if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
          e.preventDefault();
          prevPage();
        } else if (e.key.toLowerCase() === 'f') {
          e.preventDefault();
          toggleFullscreen();
        } else if (e.key === 'Escape') {
          closeViewer();
        }
      });

      (async () => {
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        dateEl.value = deepDate || `${yyyy}-${mm}-${dd}`;

        const ok = await loadIndex(false);
        if (!ok) return;
        if (deepDate) await loadForDate(deepDate);
      })();
    </script>
  </body>
</html>